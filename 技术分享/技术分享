GC探秘
理解GC只需要以下三个问题。

哪些内存需要回收？
jvm的内存节后主要分为：
程序计数器，虚拟机栈、本地方法栈随线程而生，随线程而灭。他们内存分配和回收都具备确定性，不需要过多考虑。
堆和方法区的内存分配和回收都是动态的，gc所关注的就是这部分内存。

什么时候回收？

GC分为minor GC 和 Full Gc
Minor GC：指发生在新生代的GC，因为Java 对象大多具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
触发时机：大多数情况下，对象直接在 Eden 区中进行分配。当 Eden区域没有足够的空间时,虚拟机将会发起一次 Minor GC；

Full GC：指发生在老年代的GC，Major GC的速度一般会比Minor GC慢10倍以上。
触发时机：当老年代没有足够空间的话，那么就会进行一次 Full GC。

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果大于则进行Minor GC，如果小于则看HandlePromotionFailure设置是否允许担保失败（不允许则直接Full GC）。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试Minor GC（如果尝试失败也会触发Full GC），如果小于则进行Full GC。


新生代和老生代

虚拟机采用分代收集的思想来管理内存。分为新生代，老年代。虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被survivor容纳，将被移动到Suivivor空间中，并且对象年龄设为1.对象每经历一次Minor GC，年龄就加1.当它的年龄增加到一定程度（默认15），就会被移入老年代。这个阈值可以通过参数--XX：MaxTenuringThreshold设置。
还有另一种情况，当Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

如何回收？
两类算法：

判断对象是否已死即是否可以回收的算法

	引用计数算法：
	给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1：当引用失效时，计数器就减1：任何时候计数器为0的对象就是没有被使用的。

	可达性算法：
	通过一系列称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象是不可用的。
	java语言中，可以做为GC Roots的对象包括：
	虚拟机栈中引用的对象。？
	方法区中类静态属性引用的对象。？
	方法区常量引用的对象。？
	本地方法栈中的native方法引用的对象。？
	
	引用的类型：
			强引用（Strong Refrence）
			软引用（Soft Refrence）
			弱引用（Weak Refrence）
			虚引用（Phantom Refrence）


垃圾收集算法
	标记-清除算法
	复制算法 新生代
	标记-整理算法 老年代
	分带收集算法

HotSpot虚拟机中的实现：

垃圾收集器
  hotspot虚拟机中主要有以下垃圾收集器
  	Serial 
    parnew
	Parallel 
    CMS 
 	G1 




内存分配和回收策略


参考：http://www.importnew.com/13504.html