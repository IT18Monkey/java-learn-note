项目介绍



Java基础

1、List 和 Set 的区别
	元素是否唯一。
	ArrayList数组实现,LinkedList双向链表实现。
	HashSet ， LinkedHashSet ， TreeSet 内部都是对应的map实现的。
2、HashSet 是如何保证不重复的
	内部用hashmap实现。元素存为key，value为Object对象。不用null的原因是hashset的remove方法会通过hashmap的remove方法是否返回null值来判断是否remove成功。

3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?
HashMap 在并发时可能出现的问题主要是两方面：
	* put的时候导致的多线程数据不一致
	比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。
	* resize而引起死循环（JDK1.8已经不会出现该问题）
	这种情况发生在JDK1.7 中HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。

4、HashMap 的扩容过程 

5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？ 
	* 优化了数据结构，引入红黑树，链表长度大于8时触发
	* hash冲突时采用尾插法。

Java 并发

1、synchronized 的实现原理以及锁优化？

2、volatile 的实现原理？ 
3、Java 的信号灯？
	Semaphore
4、synchronized 在静态方法和普通方法的区别？
    锁对象的不同
5、怎么实现所有线程在等待某个事件的发生才会去执行？
    countdownlatch和cyclicbarrier。
6、Java技术之AQS详解 https://www.jianshu.com/p/da9d051dcc3d
6、CAS？CAS 有什么缺陷，如何解决？ 7、synchronized 和 lock 有什么区别？ 8、Hashtable 是怎么加锁的 ？ 10、ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？ 11、AQS 12、如何检测死锁？怎么预防死锁？ 13、Java 内存模型？ 14、如何保证多线程下 i++ 结果正确？ 15、线程池的种类，区别和使用场景？ 16、分析线程池的实现原理和线程的调度过程？ 17、线程池如何调优，最大数目如何确认？ 18、ThreadLocal原理，用的时候需要注意什么？ 

Spring

1、BeanFactory 和 FactoryBean？ 2、Spring IOC 的理解，其初始化过程？ 3、BeanFactory 和 ApplicationContext？ 4、Spring Bean 的生命周期，如何被管理的？ 5、Spring Bean 的加载过程是怎样的？ 6、如果要你实现Spring AOP，请问怎么实现？ 7、如果要你实现Spring IOC，你会注意哪些问题？ 8、Spring 是如何管理事务的，事务管理机制？ 9、Spring 的不同事务传播行为有哪些，干什么用的？ 10、Spring 中用到了那些设计模式？ 

Netty

1、BIO、NIO和AIO
2、Netty 的各大组件
3、Netty的线程模型
4、TCP 粘包/拆包的原因及解决方法 
5、了解哪几种序列化协议？包括使用场景和如何去选择 
6、Netty的零拷贝实现 7、Netty的高性能表现在哪些方面

分布式相关

1、Dubbo的底层实现原理和机制 2、描述一个服务从发布到被消费的详细过程 3、分布式系统怎么做服务治理 4、接口的幂等性的概念 5、消息中间件如何解决消息丢失问题 6、Dubbo的服务请求失败怎么处理 7、重连机制会不会造成错误 8、对分布式事务的理解 9、如何实现负载均衡，有哪些算法可以实现？ 10、Zookeeper的用途，选举的原理是什么？ 11、数据的垂直拆分水平拆分。 12、zookeeper原理和适用场景 13、zookeeper watch机制 14、redis/zk节点宕机如何处理 15、分布式集群下如何做到唯一序列号 16、如何做一个分布式锁 

缓存

1、Redis用过哪些数据数据，以及Redis底层怎么实现 
string 
list
hash
set
sorted set
Bitmaps
HyperLogLogs 估算集合基数

2、Redis缓存穿透，缓存雪崩 
	* 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
	* 可以通过缓存reload机制，预先去更新缓存.
	* 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
	* 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。

3、如何使用Redis来实现分布式锁 
	SET NX
4、Redis的并发竞争问题如何解决 
5、Redis持久化的几种方式，优缺点是什么，怎么实现的 
	* rdb 慢，全量，文件体积小
	* aof 增量，文件体积大
6、Redis的缓存失效策略 
	* 消极方法（passive way）
	* 积极方法（active way）
7、Redis集群，高可用，原理 
主从复制，哨兵，集群cluster多主多从。

8、Redis缓存分片 
	客户端分片
	服务端分片（集群）
9、Redis的数据淘汰策略
	volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
	volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
	volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
	allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
	allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
	no-enviction（驱逐）：禁止驱逐数据
JVM

1、详细jvm内存模型 2、讲讲什么情况下回出现内存溢出，内存泄漏？  3、说说Java线程栈 4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？ 5、JVM 出现 fullGC 很频繁，怎么去线上排查问题？ 6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？ 7、类的实例化顺序 8、JVM垃圾回收机制，何时触发MinorGC等操作 9、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的 10、各种回收器，各自优缺点，重点CMS、G1 11、各种回收算法 12、OOM错误，stackoverflow错误，permgen space错误

常见算法
1.快速排序
 public void sort(int arr[], int low, int high) {
        int l = low;
        int h = high;
        int med = arr[low];
        while (l < h) {
            while (l < h) {
                if (arr[h] < med) {
                    int temp = arr[h];
                    arr[h] =arr[l];
                    arr[l] = temp;
                    l++;
                    break;
                } else {
                    h--;
                }
            }
            while (l < h) {
                if (arr[l] > med) {
                    int temp = arr[l];
                    arr[l] =arr[h];
                    arr[h] = temp;
                    h--;
                    break;
                } else {
                    l++;
                }
            }
        }
        if (l - 1 > low) {
            sort(arr, low, l - 1);
        }
        if (h + 1 < high) {
            sort(arr, h + 1, high);
        }
    }

2.堆排序

3.归并排序
4.二分查找
5.线性查找算法（BFPRT）
6.DFS(深度优先搜索)
7.BFS(广度优先搜索)
8.动态规划